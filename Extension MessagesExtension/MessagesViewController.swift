//
//  MessagesViewController.swift
//  Extension MessagesExtension
//
//  Created by Don Do on 3/10/25.
//

import UIKit
import SwiftUI
import Messages

class MessagesViewController: MSMessagesAppViewController {
    
    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.
        
        // Initial UI will be set in willBecomeActive
    }
    
    // Helper method to present a SwiftUI view
    public func presentSwiftUIView<Content: View>(_ content: Content) {
        // Remove any existing child view controllers
        for child in children {
            child.willMove(toParent: nil)
            child.view.removeFromSuperview()
            child.removeFromParent()
        }
        
        let hostingController = UIHostingController(rootView: content)
        addChild(hostingController)
        view.addSubview(hostingController.view)
        hostingController.view.frame = view.bounds
        hostingController.view.autoresizingMask = [.flexibleWidth, .flexibleHeight]
        hostingController.didMove(toParent: self)
    }
    
    // MARK: - Conversation Handling
    
    override func willBecomeActive(with conversation: MSConversation) {
        // Called when the extension is about to move from the inactive to active state.
        // This will happen when the extension is about to present UI.
        
        // Check if there is a selected message
        if let message = conversation.selectedMessage {
            presentEventFromMessage(message, in: conversation)
        } else {
            // Show the default create event UI
            let swiftUIView = MessagesView(controller: self)
            presentSwiftUIView(swiftUIView)
        }
    }
    
    override func didResignActive(with conversation: MSConversation) {
        // Called when the extension is about to move from the active to inactive state.
        // This will happen when the user dismisses the extension, changes to a different
        // conversation or quits Messages.
        
        // Use this method to release shared resources, save user data, invalidate timers,
        // and store enough state information to restore your extension to its current state
        // in case it is terminated later.
    }
   
    override func didReceive(_ message: MSMessage, conversation: MSConversation) {
        // Called when a message arrives that was generated by another instance of this
        // extension on a remote device.
        
        // Process the received message
        presentEventFromMessage(message, in: conversation)
    }
    
    override func didStartSending(_ message: MSMessage, conversation: MSConversation) {
        // Called when the user taps the send button.
        if let event = extractEventFromMessage(message) {
            // Save this event as one that the user has sent
            EventStorage.saveEvent(event)
        }
    }
    
    override func didCancelSending(_ message: MSMessage, conversation: MSConversation) {
        // Called when the user deletes the message without sending it.
    
        // Use this to clean up state related to the deleted message.
    }
    
    override func willTransition(to presentationStyle: MSMessagesAppPresentationStyle) {
        // Called before the extension transitions to a new presentation style.
    
        // Use this method to prepare for the change in presentation style.
    }
    
    override func didTransition(to presentationStyle: MSMessagesAppPresentationStyle) {
        // Called after the extension transitions to a new presentation style.
    
        // Use this method to finalize any behaviors associated with the change in presentation style.
    }
    
    // Helper method to present an event from a message
    private func presentEventFromMessage(_ message: MSMessage, in conversation: MSConversation) {
        guard let messageURL = message.url, let components = URLComponents(url: messageURL, resolvingAgainstBaseURL: false) else {
            return
        }
        
        let queryItems = components.queryItems ?? []
        
        // Extract event data from URL components
        guard let name = queryItems.first(where: { $0.name == "name" })?.value,
              let startTimeString = queryItems.first(where: { $0.name == "startTime" })?.value,
              let endTimeString = queryItems.first(where: { $0.name == "endTime" })?.value,
              let timeZoneID = queryItems.first(where: { $0.name == "timeZone" })?.value,
              let startTime = Int(startTimeString),
              let endTime = Int(endTimeString) else {
            return
        }
        
        // Get the timeZone
        let timeZone = TimeZone(identifier: timeZoneID) ?? TimeZone.current
        
        // Extract dates
        var dates: [Date] = []
        for item in queryItems {
            if item.name.starts(with: "date"), let timeIntervalString = item.value, let timeInterval = Double(timeIntervalString) {
                let date = Date(timeIntervalSince1970: timeInterval)
                dates.append(date)
            }
        }
        
        // Create the event
        let event = Event(name: name, dates: dates, startTime: startTime, endTime: endTime, timeZone: timeZone)
        
        // Extract availability data from the message
        for item in queryItems {
            if item.name.starts(with: "slot") {
                let components = item.name.components(separatedBy: "_")
                
                // Check if this is a slot start/end time or user entry
                if components.count >= 2 {
                    let slotIndex = components[0].dropFirst(4) // Remove "slot"
                    
                    if components[1] == "start", let timeString = item.value, let startTime = Double(timeString) {
                        // Look for the matching end time
                        if let endTimeItem = queryItems.first(where: { $0.name == "slot\(slotIndex)_end" }),
                           let endTimeString = endTimeItem.value,
                           let endTime = Double(endTimeString) {
                            
                            let startDate = Date(timeIntervalSince1970: startTime)
                            let endDate = Date(timeIntervalSince1970: endTime)
                            let timeSlot = DateInterval(start: startDate, end: endDate)
                            
                            // Find all users for this time slot
                            var userIndex = 0
                            while let userItem = queryItems.first(where: { $0.name == "slot\(slotIndex)_user\(userIndex)" }) {
                                if let userName = userItem.value {
                                    // Add this user to the event's availability
                                    if event.avail[timeSlot] != nil {
                                        event.avail[timeSlot]?.append(userName)
                                    } else {
                                        event.avail[timeSlot] = [userName]
                                    }
                                    
                                    // Add user to event's users list if not already there
                                    if !event.users.contains(userName) {
                                        event.users.append(userName)
                                    }
                                }
                                userIndex += 1
                            }
                        }
                    }
                }
            }
        }
        
        // Present the HeatmapView for the user to edit their availability
        let heatmapView = HeatmapView(event: event, controller: self)
        presentSwiftUIView(heatmapView)
    }
    
    // Extract an event object from a message
    private func extractEventFromMessage(_ message: MSMessage) -> Event? {
        guard let messageURL = message.url, let components = URLComponents(url: messageURL, resolvingAgainstBaseURL: false) else {
            return nil
        }
        
        let queryItems = components.queryItems ?? []
        
        // Extract event data from URL components
        guard let name = queryItems.first(where: { $0.name == "name" })?.value,
              let startTimeString = queryItems.first(where: { $0.name == "startTime" })?.value,
              let endTimeString = queryItems.first(where: { $0.name == "endTime" })?.value,
              let timeZoneID = queryItems.first(where: { $0.name == "timeZone" })?.value,
              let startTime = Int(startTimeString),
              let endTime = Int(endTimeString) else {
            return nil
        }
        
        // Get the timeZone
        let timeZone = TimeZone(identifier: timeZoneID) ?? TimeZone.current
        
        // Extract dates
        var dates: [Date] = []
        for item in queryItems {
            if item.name.starts(with: "date"), let timeIntervalString = item.value, let timeInterval = Double(timeIntervalString) {
                let date = Date(timeIntervalSince1970: timeInterval)
                dates.append(date)
            }
        }
        
        // Create the event
        let event = Event(name: name, dates: dates, startTime: startTime, endTime: endTime, timeZone: timeZone)
        
        // Extract availability data from the message
        for item in queryItems {
            if item.name.starts(with: "slot") {
                let components = item.name.components(separatedBy: "_")
                
                // Check if this is a slot start/end time or user entry
                if components.count >= 2 {
                    let slotIndex = components[0].dropFirst(4) // Remove "slot"
                    
                    if components[1] == "start", let timeString = item.value, let startTime = Double(timeString) {
                        // Look for the matching end time
                        if let endTimeItem = queryItems.first(where: { $0.name == "slot\(slotIndex)_end" }),
                           let endTimeString = endTimeItem.value,
                           let endTime = Double(endTimeString) {
                            
                            let startDate = Date(timeIntervalSince1970: startTime)
                            let endDate = Date(timeIntervalSince1970: endTime)
                            let timeSlot = DateInterval(start: startDate, end: endDate)
                            
                            // Find all users for this time slot
                            var userIndex = 0
                            while let userItem = queryItems.first(where: { $0.name == "slot\(slotIndex)_user\(userIndex)" }) {
                                if let userName = userItem.value {
                                    // Add this user to the event's availability
                                    if event.avail[timeSlot] != nil {
                                        event.avail[timeSlot]?.append(userName)
                                    } else {
                                        event.avail[timeSlot] = [userName]
                                    }
                                    
                                    // Add user to event's users list if not already there
                                    if !event.users.contains(userName) {
                                        event.users.append(userName)
                                    }
                                }
                                userIndex += 1
                            }
                        }
                    }
                }
            }
        }
        
        return event
    }
    
    // Get current device identifier for consistent user identification
    func getCurrentDeviceIdentifier() -> String {
        return UIDevice.current.identifierForVendor?.uuidString ?? "Anonymous"
    }
    
    // Load all events that the current user has sent
    func loadSentEvents() -> [Event] {
        return EventStorage.getSavedEvents()
    }
}
